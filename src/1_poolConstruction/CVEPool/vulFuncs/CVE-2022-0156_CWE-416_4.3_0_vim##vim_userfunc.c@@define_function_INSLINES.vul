+ * Get a next line, store it in "eap" if appropriate and put the line in
+ * "lines_to_free" to free the line later.
+	garray_T	*lines_to_free,
+	if (lines_to_free->ga_len > 0
+		&& *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)
+						   [lines_to_free->ga_len - 1])
+	ga_add_string(lines_to_free, theline);
+    garray_T	*lines_to_free)
+	    char_u *theline = get_function_line(eap, lines_to_free, 0,
+	garray_T    *lines_to_free)
+	    theline = get_function_line(eap, lines_to_free, indent,
+			// change "eap->cmdlinep" to point to the last fetched
+			// line.
+			if (lines_to_free->ga_len > 0
+				&& *eap->cmdlinep !=
+					    ((char_u **)lines_to_free->ga_data)
+						   [lines_to_free->ga_len - 1])
+			    // *cmdlinep will be freed later, thus remove the
+			    // line from lines_to_free.
+			    *eap->cmdlinep = ((char_u **)lines_to_free->ga_data)
+						   [lines_to_free->ga_len - 1];
+			    --lines_to_free->ga_len;
+    if (get_function_body(&eap, &newlines, NULL,
+					     &evalarg->eval_tofree_ga) == FAIL)
+ * "lines_to_free" is a list of strings to be freed later.
+define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)
+			 eap, lines_to_free) == FAIL)
+    if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL
