+#include 
+/*
+ * Lock protecting event handling loop against removing event channels.
+ * Adding of event channels is no issue as the associated IRQ becomes active
+ * only after everything is setup (before request_[threaded_]irq() the handler
+ * can't be entered for an event, as the event channel will be unmasked only
+ * then).
+ */
+static DEFINE_RWLOCK(evtchn_rwlock);
+
+/*
+ * Lock hierarchy:
+ *
+ * irq_mapping_update_lock
+ *   evtchn_rwlock
+ *     IRQ-desc lock
+ */
+
+		WRITE_ONCE(evtchn_to_irq[row][col], -1);
+	WRITE_ONCE(evtchn_to_irq[row][col], irq);
+	return READ_ONCE(evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)]);
+	const struct irq_info *info = NULL;
+
+	if (likely(irq < nr_irqs))
+		info = info_for_irq(irq);
+	if (!info)
+	return info->evtchn;
+	unsigned long flags;
+	write_lock_irqsave(&evtchn_rwlock, flags);
+
+	write_unlock_irqrestore(&evtchn_rwlock, flags);
+
